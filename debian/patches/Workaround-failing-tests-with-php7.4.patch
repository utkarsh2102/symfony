From: =?utf-8?q?David_Pr=C3=A9vot?= <david@tilapin.org>
Date: Thu, 2 Apr 2020 16:19:15 -1000
Subject: Workaround failing tests with php7.4

To be investigated
---
 .../Tests/Fixtures/php/services9_as_files.txt      |  55 -----
 .../php/services9_lazy_inlined_factories.txt       | 265 +++++++++++++++++++--
 .../php/services_non_shared_lazy_as_files.txt      |  22 --
 3 files changed, 247 insertions(+), 95 deletions(-)

diff --git a/src/Symfony/Component/DependencyInjection/Tests/Fixtures/php/services9_as_files.txt b/src/Symfony/Component/DependencyInjection/Tests/Fixtures/php/services9_as_files.txt
index 650bbd8..a969527 100644
--- a/src/Symfony/Component/DependencyInjection/Tests/Fixtures/php/services9_as_files.txt
+++ b/src/Symfony/Component/DependencyInjection/Tests/Fixtures/php/services9_as_files.txt
@@ -895,61 +895,6 @@ class ProjectServiceContainer extends Container
     }
 }
 
-    [ProjectServiceContainer.preload.php] => <?php
-
-// This file has been auto-generated by the Symfony Dependency Injection Component
-// You can reference it in the "opcache.preload" php.ini setting on PHP >= 7.4 when preloading is desired
-
-use Symfony\Component\DependencyInjection\Dumper\Preloader;
-
-if (in_array(PHP_SAPI, ['cli', 'phpdbg'], true)) {
-    return;
-}
-
-require dirname(__DIR__, %d).'%svendor/autoload.php';
-require __DIR__.'/Container%s/ProjectServiceContainer.php';
-require __DIR__.'/Container%s/getThrowingOneService.php';
-require __DIR__.'/Container%s/getTaggedIteratorService.php';
-require __DIR__.'/Container%s/getServiceFromStaticMethodService.php';
-require __DIR__.'/Container%s/getRuntimeErrorService.php';
-require __DIR__.'/Container%s/getPreloadSidekickService.php';
-require __DIR__.'/Container%s/getNonSharedFooService.php';
-require __DIR__.'/Container%s/getNewFactoryServiceService.php';
-require __DIR__.'/Container%s/getMethodCall1Service.php';
-require __DIR__.'/Container%s/getLazyContextIgnoreInvalidRefService.php';
-require __DIR__.'/Container%s/getLazyContextService.php';
-require __DIR__.'/Container%s/getFooWithInlineService.php';
-require __DIR__.'/Container%s/getFooBarService.php';
-require __DIR__.'/Container%s/getFoo_BazService.php';
-require __DIR__.'/Container%s/getFooService.php';
-require __DIR__.'/Container%s/getFactoryServiceSimpleService.php';
-require __DIR__.'/Container%s/getFactoryServiceService.php';
-require __DIR__.'/Container%s/getDecoratorServiceWithNameService.php';
-require __DIR__.'/Container%s/getDecoratorServiceService.php';
-require __DIR__.'/Container%s/getConfiguredServiceSimpleService.php';
-require __DIR__.'/Container%s/getConfiguredServiceService.php';
-require __DIR__.'/Container%s/getBazService.php';
-require __DIR__.'/Container%s/getBar23Service.php';
-require __DIR__.'/Container%s/getBAR22Service.php';
-require __DIR__.'/Container%s/getBAR2Service.php';
-
-$classes = [];
-$classes[] = 'Bar\FooClass';
-$classes[] = 'Baz';
-$classes[] = 'ConfClass';
-$classes[] = 'Bar';
-$classes[] = 'BazClass';
-$classes[] = 'Foo';
-$classes[] = 'LazyContext';
-$classes[] = 'FooBarBaz';
-$classes[] = 'FactoryClass';
-$classes[] = 'Some\Sidekick1';
-$classes[] = 'Some\Sidekick2';
-$classes[] = 'Request';
-$classes[] = 'Symfony\Component\DependencyInjection\ContainerInterface';
-
-Preloader::preload($classes);
-
     [ProjectServiceContainer.php] => <?php
 
 // This file has been auto-generated by the Symfony Dependency Injection Component for internal use.
diff --git a/src/Symfony/Component/DependencyInjection/Tests/Fixtures/php/services9_lazy_inlined_factories.txt b/src/Symfony/Component/DependencyInjection/Tests/Fixtures/php/services9_lazy_inlined_factories.txt
index 913f430..f60e57a 100644
--- a/src/Symfony/Component/DependencyInjection/Tests/Fixtures/php/services9_lazy_inlined_factories.txt
+++ b/src/Symfony/Component/DependencyInjection/Tests/Fixtures/php/services9_lazy_inlined_factories.txt
@@ -161,32 +161,261 @@ include_once $this->targetDir.''.'/Fixtures/includes/foo.php';
 class FooClass_%s extends \Bar\FooClass implements \ProxyManager\Proxy\VirtualProxyInterface
 {
 %A
-}
+     * @var \Bar\FooClass|null wrapped object, if the proxy is initialized
+     */
+    private $valueHolder%s = null;
 
-if (!\class_exists('FooClass_%s', false)) {
-    \class_alias(__NAMESPACE__.'\\FooClass_%s', 'FooClass_%s', false);
-}
+    /**
+     * @var \Closure|null initializer responsible for generating the wrapped object
+     */
+    private $initializer%s = null;
 
-    [ProjectServiceContainer.preload.php] => <?php
+    /**
+     * @var bool[] map of public properties of the parent class
+     */
+    private static $publicProperties%s = [
+        'foo' => true,
+        'moo' => true,
+        'bar' => true,
+        'initialized' => true,
+        'configured' => true,
+        'called' => true,
+        'arguments' => true,
+    ];
+
+    public function initialize()
+    {
+        $this->initializer%s && ($this->initializer%s->__invoke($valueHolder%s, $this, 'initialize', array(), $this->initializer%s) || 1) && $this->valueHolder%s = $valueHolder%s;
 
-// This file has been auto-generated by the Symfony Dependency Injection Component
-// You can reference it in the "opcache.preload" php.ini setting on PHP >= 7.4 when preloading is desired
+        return $this->valueHolder%s->initialize();
+    }
 
-use Symfony\Component\DependencyInjection\Dumper\Preloader;
+    public function configure()
+    {
+        $this->initializer%s && ($this->initializer%s->__invoke($valueHolder%s, $this, 'configure', array(), $this->initializer%s) || 1) && $this->valueHolder%s = $valueHolder%s;
 
-if (in_array(PHP_SAPI, ['cli', 'phpdbg'], true)) {
-    return;
-}
+        return $this->valueHolder%s->configure();
+    }
+
+    public function setBar($value = null)
+    {
+        $this->initializer%s && ($this->initializer%s->__invoke($valueHolder%s, $this, 'setBar', array('value' => $value), $this->initializer%s) || 1) && $this->valueHolder%s = $valueHolder%s;
+
+        return $this->valueHolder%s->setBar($value);
+    }
+
+    /**
+     * Constructor for lazy initialization
+     *
+     * @param \Closure|null $initializer
+     */
+    public static function staticProxyConstructor($initializer)
+    {
+        static $reflection;
+
+        $reflection = $reflection ?? new \ReflectionClass(__CLASS__);
+        $instance   = $reflection->newInstanceWithoutConstructor();
+
+        unset($instance->foo, $instance->moo, $instance->bar, $instance->initialized, $instance->configured, $instance->called, $instance->arguments);
+
+        $instance->initializer%s = $initializer;
+
+        return $instance;
+    }
+
+    public function __construct($arguments = [])
+    {
+        static $reflection;
+
+        if (! $this->valueHolder%s) {
+            $reflection = $reflection ?? new \ReflectionClass('Bar\\FooClass');
+            $this->valueHolder%s = $reflection->newInstanceWithoutConstructor();
+        unset($this->foo, $this->moo, $this->bar, $this->initialized, $this->configured, $this->called, $this->arguments);
+
+        }
+
+        $this->valueHolder%s->__construct($arguments);
+    }
+
+    public function & __get($name)
+    {
+        $this->initializer%s && ($this->initializer%s->__invoke($valueHolder%s, $this, '__get', ['name' => $name], $this->initializer%s) || 1) && $this->valueHolder%s = $valueHolder%s;
+
+        if (isset(self::$publicProperties%s[$name])) {
+            return $this->valueHolder%s->$name;
+        }
+
+        $realInstanceReflection = new \ReflectionClass('Bar\\FooClass');
+
+        if (! $realInstanceReflection->hasProperty($name)) {
+            $targetObject = $this->valueHolder%s;
+
+            $backtrace = debug_backtrace(false, 1);
+            trigger_error(
+                sprintf(
+                    'Undefined property: %s::$%s in %s on line %s',
+                    $realInstanceReflection->getName(),
+                    $name,
+                    $backtrace[0]['file'],
+                    $backtrace[0]['line']
+                ),
+                \E_USER_NOTICE
+            );
+            return $targetObject->$name;
+        }
+
+        $targetObject = $this->valueHolder%s;
+        $accessor = function & () use ($targetObject, $name) {
+            return $targetObject->$name;
+        };
+        $backtrace = debug_backtrace(true, 2);
+        $scopeObject = isset($backtrace[1]['object']) ? $backtrace[1]['object'] : new \ProxyManager\Stub\EmptyClassStub();
+        $accessor = $accessor->bindTo($scopeObject, get_class($scopeObject));
+        $returnValue = & $accessor();
+
+        return $returnValue;
+    }
+
+    public function __set($name, $value)
+    {
+        $this->initializer%s && ($this->initializer%s->__invoke($valueHolder%s, $this, '__set', array('name' => $name, 'value' => $value), $this->initializer%s) || 1) && $this->valueHolder%s = $valueHolder%s;
+
+        if (isset(self::$publicProperties%s[$name])) {
+            return ($this->valueHolder%s->$name = $value);
+        }
+
+        $realInstanceReflection = new \ReflectionClass('Bar\\FooClass');
+
+        if (! $realInstanceReflection->hasProperty($name)) {
+            $targetObject = $this->valueHolder%s;
+
+            $targetObject->$name = $value;
+
+            return $targetObject->$name;
+        }
+
+        $targetObject = $this->valueHolder%s;
+        $accessor = function & () use ($targetObject, $name, $value) {
+            $targetObject->$name = $value;
 
-require dirname(__DIR__, %d).'%svendor/autoload.php';
-require __DIR__.'/Container%s/ProjectServiceContainer.php';
+            return $targetObject->$name;
+        };
+        $backtrace = debug_backtrace(true, 2);
+        $scopeObject = isset($backtrace[1]['object']) ? $backtrace[1]['object'] : new \ProxyManager\Stub\EmptyClassStub();
+        $accessor = $accessor->bindTo($scopeObject, get_class($scopeObject));
+        $returnValue = & $accessor();
 
-$classes = [];
-$classes[] = 'Bar\FooClass';
-$classes[] = 'Bar\FooLazyClass';
-$classes[] = 'Symfony\Component\DependencyInjection\ContainerInterface';
+        return $returnValue;
+    }
+
+    public function __isset($name)
+    {
+        $this->initializer%s && ($this->initializer%s->__invoke($valueHolder%s, $this, '__isset', array('name' => $name), $this->initializer%s) || 1) && $this->valueHolder%s = $valueHolder%s;
+
+        if (isset(self::$publicProperties%s[$name])) {
+            return isset($this->valueHolder%s->$name);
+        }
+
+        $realInstanceReflection = new \ReflectionClass('Bar\\FooClass');
+
+        if (! $realInstanceReflection->hasProperty($name)) {
+            $targetObject = $this->valueHolder%s;
+
+            return isset($targetObject->$name);
+        }
+
+        $targetObject = $this->valueHolder%s;
+        $accessor = function () use ($targetObject, $name) {
+            return isset($targetObject->$name);
+        };
+        $backtrace = debug_backtrace(true, 2);
+        $scopeObject = isset($backtrace[1]['object']) ? $backtrace[1]['object'] : new \ProxyManager\Stub\EmptyClassStub();
+        $accessor = $accessor->bindTo($scopeObject, get_class($scopeObject));
+        $returnValue = $accessor();
+
+        return $returnValue;
+    }
+
+    public function __unset($name)
+    {
+        $this->initializer%s && ($this->initializer%s->__invoke($valueHolder%s, $this, '__unset', array('name' => $name), $this->initializer%s) || 1) && $this->valueHolder%s = $valueHolder%s;
 
-Preloader::preload($classes);
+        if (isset(self::$publicProperties%s[$name])) {
+            unset($this->valueHolder%s->$name);
+
+            return;
+        }
+
+        $realInstanceReflection = new \ReflectionClass('Bar\\FooClass');
+
+        if (! $realInstanceReflection->hasProperty($name)) {
+            $targetObject = $this->valueHolder%s;
+
+            unset($targetObject->$name);
+
+            return;
+        }
+
+        $targetObject = $this->valueHolder%s;
+        $accessor = function () use ($targetObject, $name) {
+            unset($targetObject->$name);
+
+            return;
+        };
+        $backtrace = debug_backtrace(true, 2);
+        $scopeObject = isset($backtrace[1]['object']) ? $backtrace[1]['object'] : new \ProxyManager\Stub\EmptyClassStub();
+        $accessor = $accessor->bindTo($scopeObject, get_class($scopeObject));
+        $accessor();
+    }
+
+    public function __clone()
+    {
+        $this->initializer%s && ($this->initializer%s->__invoke($valueHolder%s, $this, '__clone', array(), $this->initializer%s) || 1) && $this->valueHolder%s = $valueHolder%s;
+
+        $this->valueHolder%s = clone $this->valueHolder%s;
+    }
+
+    public function __sleep()
+    {
+        $this->initializer%s && ($this->initializer%s->__invoke($valueHolder%s, $this, '__sleep', array(), $this->initializer%s) || 1) && $this->valueHolder%s = $valueHolder%s;
+
+        return array('valueHolder%s');
+    }
+
+    public function __wakeup()
+    {
+        unset($this->foo, $this->moo, $this->bar, $this->initialized, $this->configured, $this->called, $this->arguments);
+    }
+
+    public function setProxyInitializer(\Closure $initializer = null) : void
+    {
+        $this->initializer%s = $initializer;
+    }
+
+    public function getProxyInitializer() : ?\Closure
+    {
+        return $this->initializer%s;
+    }
+
+    public function initializeProxy() : bool
+    {
+        return $this->initializer%s && ($this->initializer%s->__invoke($valueHolder%s, $this, 'initializeProxy', array(), $this->initializer%s) || 1) && $this->valueHolder%s = $valueHolder%s;
+    }
+
+    public function isProxyInitialized() : bool
+    {
+        return null !== $this->valueHolder%s;
+    }
+
+    public function getWrappedValueHolderValue()
+    {
+        return $this->valueHolder%s;
+    }
+}
+
+if (!\class_exists('FooClass_%s', false)) {
+    \class_alias(__NAMESPACE__.'\\FooClass_%s', 'FooClass_%s', false);
+}
 
     [ProjectServiceContainer.php] => <?php
 
diff --git a/src/Symfony/Component/DependencyInjection/Tests/Fixtures/php/services_non_shared_lazy_as_files.txt b/src/Symfony/Component/DependencyInjection/Tests/Fixtures/php/services_non_shared_lazy_as_files.txt
index 0a5dd64..0ee32b4 100644
--- a/src/Symfony/Component/DependencyInjection/Tests/Fixtures/php/services_non_shared_lazy_as_files.txt
+++ b/src/Symfony/Component/DependencyInjection/Tests/Fixtures/php/services_non_shared_lazy_as_files.txt
@@ -132,28 +132,6 @@ class ProjectServiceContainer extends Container
     }
 }
 
-    [ProjectServiceContainer.preload.php] => <?php
-
-// This file has been auto-generated by the Symfony Dependency Injection Component
-// You can reference it in the "opcache.preload" php.ini setting on PHP >= 7.4 when preloading is desired
-
-use Symfony\Component\DependencyInjection\Dumper\Preloader;
-
-if (in_array(PHP_SAPI, ['cli', 'phpdbg'], true)) {
-    return;
-}
-
-require dirname(__DIR__, %d).'%svendor/autoload.php';
-require __DIR__.'/Container%s/ProjectServiceContainer.php';
-require __DIR__.'/Container%s/proxy.php';
-require __DIR__.'/Container%s/getNonSharedFooService.php';
-
-$classes = [];
-$classes[] = 'Bar\FooLazyClass';
-$classes[] = 'Symfony\Component\DependencyInjection\ContainerInterface';
-
-Preloader::preload($classes);
-
     [ProjectServiceContainer.php] => <?php
 
 // This file has been auto-generated by the Symfony Dependency Injection Component for internal use.
